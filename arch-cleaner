#!/bin/bash
# ┌──────────────────────────────────────────────┐
# │                 Arch-Cleaner                 │
# │                                              │
# │  A minimal, safe, and interactive cleanup    │
# │  tool for Arch-based systems.                │
# └──────────────────────────────────────────────┘

set -euo pipefail

# ──────────────── ASCII LOGO ────────────────
cat << "EOF"

   _____                .__                _________ .__                                     
  /  _  \_______   ____ |  |__             \_   ___ \|  |   ____ _____    ____   ___________ 
 /  /_\  \_  __ \_/ ___\|  |  \    ______  /    \  \/|  | _/ __ \\__  \  /    \_/ __ \_  __ \
/    |    \  | \/\  \___|   Y  \  /_____/  \     \___|  |_\  ___/ / __ \|   |  \  ___/|  | \/
\____|__  /__|    \___  >___|  /            \______  /____/\___  >____  /___|  /\___  >__|   
        \/            \/     \/                    \/          \/     \/     \/     \/       

EOF

# ──────────────── HELPERS ────────────────

# Exit if not root
[ "$(id -u)" -eq 0 ] || { echo "Please run as root (use sudo)." >&2; exit 1; }

# Safe pacman query wrapper (avoids errors if empty)
safe_pacman_query() {
    pacman "$@" 2>/dev/null || true
}

# ──────────────── FLAGS & ARGS ────────────────

BACKUP=0
CLEAN_TRASH=0
REBOOT=0
AGGRESSIVE=0

# If args provided, parse them (non-interactive mode)
if [[ $# -gt 0 ]]; then
    while getopts ":tra" opt; do
        case $opt in
            t) CLEAN_TRASH=1 ;;
            r) REBOOT=1 ;;
            a) AGGRESSIVE=1 ;;
            b) BACKUP=1 ;;
            \?) echo "Invalid option: -$OPTARG" >&2; exit 1 ;;
        esac
    done
else
# ──────────────── INTERACTIVE MENU ────────────────

echo "Interactive Cleanup Mode"
    echo "Select options (press Enter to skip):"

    read -rp "Backup with Timeshift? (y/N): " -n 1 -r
    echo
    [[ $REPLY =~ ^[Yy]$ ]] && BACKUP=1
    
    read -rp "Empty Trash for all users? (y/N): " -n 1 -r
    echo
    [[ $REPLY =~ ^[Yy]$ ]] && CLEAN_TRASH=1

    read -rp "Reboot after cleanup? (y/N): " -n 1 -r
    echo
    [[ $REPLY =~ ^[Yy]$ ]] && REBOOT=1

    read -rp "Aggressive mode? (y/N): " -n 1 -r
    echo
    [[ $REPLY =~ ^[Yy]$ ]] && AGGRESSIVE=1
fi

# ──────────────── BACKUP WITH TIMESHIFT ────────────────

# Only proceed if user requested backup (BACKUP=1)
if [[ $BACKUP -eq 1 ]]; then
    echo -e "\n[+] Checking Timeshift installation..."

    # Check if 'timeshift' command exists in PATH
    if ! command -v timeshift &> /dev/null; then
        # If not found, attempt to install it from official repos
        echo "[!] Timeshift not found. Installing from official repositories..."
        
        # Use 'pacman -S --needed --noconfirm' to:
        #   --needed : Skip if already installed
        #   --noconfirm : Avoid interactive prompts (safe for scripts)
        if ! pacman -S --needed --noconfirm timeshift; then
            # If installation fails (e.g., no internet, repo issue), notify and disable backup
            echo "[ERROR] Failed to install Timeshift. Skipping backup." >&2
            BACKUP=0  # Prevent further backup attempts
        else
            echo "[✓] Timeshift installed successfully."
        fi
    fi

    # Only try to create a snapshot if installation succeeded (BACKUP still 1)
    if [[ $BACKUP -eq 1 ]]; then
        echo -e "\n[+] Starting Timeshift backup in 2 seconds... (Ctrl+C to cancel)"
        sleep 2

        # Check if Timeshift has been configured (i.e., snapshot location set)
        # 'timeshift --check' returns info; if no config, it mentions "No snapshots found"
        if timeshift --check 2>/dev/null | grep -q "No snapshots found"; then
            # Warn user: backup can't proceed without initial setup
            echo "[i] No existing snapshot configuration detected."
            echo "[!] Please run 'timeshift-setup' manually to configure storage first."
            echo "[!] Skipping automatic backup."
        else
            # Proceed with creating a snapshot:
            #   --create        : Take a new snapshot
            #   --comments "..." : Add descriptive comment
            #   --tags D        : Tag as "Daily" (useful for retention policies)
            timeshift --create --comments "Arch-Cleaner automated backup" --tags D
        fi
    fi
fi

# ──────────────── MAIN CLEANUP LOGIC ────────────────

echo -e "\nStarting system cleanup...\n"

# 1. Update system
echo "Updating system..."
if [[ $AGGRESSIVE -eq 1 ]]; then
    pacman -Syyu --noconfirm  # Force refresh
else
    pacman -Syu --noconfirm   # Normal update
fi

# 2. Remove orphaned packages
echo -e "\nRemoving orphaned packages..."
orphaned=$(safe_pacman_query -Qtdq)
if [[ -n "$orphaned" ]]; then
    echo "$orphaned" | pacman -Rns --noconfirm -
else
    echo "No orphaned packages."
fi

# 3. Clear pacman cache
echo -e "\nClearing pacman cache..."
if [[ $AGGRESSIVE -eq 1 ]]; then
    pacman -Scc --noconfirm  # Full wipe
else
    pacman -Sc --noconfirm   # Keep installed
fi

# 4. Remove unused packages (dangling dependencies)
echo -e "\nRemoving unused packages..."
unused=$(safe_pacman_query -Qdttq)
if [[ -n "$unused" ]]; then
    echo "$unused" | pacman -Rns --noconfirm -
else
    echo "No unused packages."
fi

# 5. Clean journal logs (keep last 50MB)
echo -e "\nCleaning journal logs..."
journalctl --vacuum-size=50M

# 6. Remove temp files (only if rebooting or aggressive)
if [[ $REBOOT -eq 1 || $AGGRESSIVE -eq 1 ]]; then
    echo -e "\nRemoving temporary files..."
    rm -rf /tmp/* /var/tmp/* 2>/dev/null || true
else
    echo -e "\nSkipping temp files (not aggressive & no reboot)."
fi

# 7. Clean user cache
echo -e "\nCleaning user cache..."
for userdir in /home/*; do
    [[ -d "$userdir/.cache" ]] || continue
    user=$(basename "$userdir")
    echo "   → $user"
    if [[ $AGGRESSIVE -eq 1 ]]; then
        rm -rf "$userdir/.cache"
    else
        rm -rf "$userdir/.cache/"*
    fi
done

# 8. Empty trash (if requested)
if [[ $CLEAN_TRASH -eq 1 ]]; then
    echo -e "\nEmptying trash for all users..."

    # Home users
    for userdir in /home/*; do
        trash="$userdir/.local/share/Trash"
        [[ -d "$trash" ]] || continue
        user=$(basename "$userdir")
        echo "   → $user"
        rm -rf "$trash/files/"* "$trash/info/"* 2>/dev/null || true
    done

    # Root trash
    root_trash="/root/.local/share/Trash"
    if [[ -d "$root_trash" ]]; then
        echo "   → root"
        rm -rf "$root_trash/files/"* "$root_trash/info/"* 2>/dev/null || true
    fi
fi

# ──────────────── FINAL STEPS ────────────────

echo -e "\nCleanup complete!"

if [[ $REBOOT -eq 1 ]]; then
    echo -e "\nRebooting in 2 seconds... (Ctrl+C to cancel)"
    sleep 2
    reboot
fi
